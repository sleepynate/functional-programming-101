#+TITLE:     Functional Programming 101
#+AUTHOR:    Nathan Dotz
#+DATE:      Codemash 2017
#+EMAIL:     nathan.dotz@gmail.com
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:nil toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   skip:nil d:nil todo:t pri:nil tags:not-in-toc timestamp:nil
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME: https://git.io/vMRB1
#+REVEAL_ROOT: file:///Users/sleepynate/Dropbox%20(Personal)/org-mode/reveal.js-3.3.0
#+REVEAL_PLUGINS: (highlight notes)
# #+REVEAL_THEME: simple

* Abstract                                                         :noexport:
In this workshop, we’ll start by exploring two functional
programming languages that these days are relegated largely to
academic study, highlighting the influences they’ve had on modern
functional programming paradigms and reinforcing these ideas with
exercises to be solved as a group along the way. First, we’ll cover
ML, a language whose ideology remains largely unchanged for over 40
years and considered the common ancestor of modern functional
languages like Haskell, OCaml and F#. Next, we’ll cover Racket, a LISP
derived from Scheme which shares similarities and probably inspiration
with a number of currently popular languages, perhaps most obviously,
Clojure and perhaps less obviously, Javascript. Lastly, we’re back to
where you work: I’ll present exercises that help to reinforce the
ideas learned from ML and Racket to be solved either in the language
of your choosing, or Javascript (the de facto language of examples and
solutions du jour).

Join me for an enlightening foray into some languages largely
forgotten or ignored by the industry that are certain to help you
bring new ideas about functional programming to your daily practice,
whatever it may be.

* Overview
  #+BEGIN_NOTES
  - Our objective for this workshop is going to be to learn the
    concepts behind functional programming
  - To do this, we're going to review 2 seminal functional programming
    languages, ML and Racket
  - Along the way, I will guide you through several exercises that
    we'll do as a group so you don't have to worry about setting up
    archaic programming environments on your machine
  - Once we've reviewed ML and Racket, we'll spend the remainder of
    the session presenting practice problems and giving you time to
    work on them in the language you normally work in, focusing on how
    to create functional-styled solutions.
  #+END_NOTES
  - Learn Functional Programming from scratch
  - Static & strongly typed functional language (ML)
  - Weak & dynamically typed functional language (Racket)
  - Work on using concepts we learned in your language
* Do your best to
  #+BEGIN_NOTES
  - You might be asking yourself why we're using two languages that
    you're not likely to ever use again once you leave here.
  - That's actually the whole point! Try to not think about the
    languages that you are familiar with and instead think about these
    languages on their own, which is the best way to let new ideas
    sink in
  - We'll worry about how to apply the methodologies we have learned
    from ML and Racket when we get to the exercises section.
  #+END_NOTES
  - Ignore the FP concepts you've tried to learn already
  - Not compare to your normal language
  - Treat these as completely new concepts
* What are we learning today?
  #+BEGIN_NOTES
  Before we get too involved, let's get to know each other a little,
  which will also help me to know what topics to concentrate on more.

  First, we'll have everyone put their hands up, and I'm going to
  recite a list of successively fancier programming terms and
  concepts, and as I list them off, if you understand that concept,
  leave your hand up in the air.

  If you don't understand a concept or term, or maybe you're familiar
  but not quite comfortable with it, take your hand down and if you're
  next to someone who has their hand up, introduce yourselves.

  You're all going to be talking to each other and me during exercises
  anyways so just get used to helping each other a little bit.

  OK, hands up.

  - variable
  - function
  - object
  - class
  - constant
  - compiler
  - interpreter
  - REPL
  - recursion
  - lambdas/anonymous functions
  - higher-order functions
  - tail-call recursion optimization
  - lexical scoping
  - referential transparency
  - functor
  - applicative functor
  - monad
  - Kleisli triple
  - zygohistomorphic prepromorphisms
  #+END_NOTES
* Standard ML
** ML
   #+BEGIN_NOTES
   - ML was thought up by Robin Milner in 1973
   - ML was not intended for implementation
   - Rather, ML was supposed to be a "Meta Language" to write proofs in
   - Showing up on the scene about 15 years after LISP, ML is often
     referred to as "LISP with types", although as we'll see, ML can
     also be quite different than LISP
   #+END_NOTES
   - Robin Milner, 1973 University of Edinburgh
   - Language spec, not implementation
   - "LISP with types"
** Standard ML
   #+BEGIN_NOTES
   - Of course, if you put something out into the world that's never
     supposed to be implemented, somebody is going to implement it
   - Those somebodies were the Princeton & Bell Labs
   #+END_NOTES
   - Proposed 1983
   - Defined 1990
   - Revised 1997
   - Implemented by Princeton & Bell Labs as SML/NJ
   - Grandparent of OCaml, Haskell, F#, Elm, Idris
** Features of ML
  - Functional programming (but not pure)
  - Tail-call optimization
  - Call-by-Value
  - Eager evaluation
  - Pattern matching
  - Garbage collection
  - Static typing
  - Type inference
* Racket
** LISP
   #+BEGIN_NOTES
   - LISP started all the way back in 1958 with John McCarthy
   - LISP is the second oldest programming language still in
     widespread use today. Fortran is older by one year.
   - Perhaps unsurprisingly LISP started not as an implementation but
     was meant to be a mathematical notation for talking about
     computer programs. It subsequently implemented by a fellow named
     Steve Russel sometime between '60 and '62
   #+END_NOTES
   - John McCarthy, 1958 MIT
   - 2nd oldest programming language
   - Started as a mathematical notation
   - LISt Processing
   - All program code comprised of lists (s-expressions)
** Scheme
  #+BEGIN_NOTES
  - Around the time Milner was coming up with with ML, Guy Steele &
    Gerald Sussman were over at MIT's AI Lab getting frustrated with
    understanding concurrency, and wrote a "tiny LISP interpreter"
  - What they ended up creating was one of the two main branches of
    LISP ­ Scheme.
  - Of its 23 reserved words, 11 are just there for convenience and
    are really just combinations of the other 12 that are so common
    there's no reason not to put them in the language.
  - In 1995, Netscape recruited a fellow named Brendan Eich with the
    intention of having him implement Scheme as a programming
    environment in their browser for creating dynamic web
    applications. However, they were also working with Sun
    Microsystems at the time, so it was ordained that the syntax be
    changed ever so slightly to resemble Java, and 10 days later,
    JavaScript was born.
  #+END_NOTES
  - Guy Steele & Gerald Sussman, 1975 MIT AI Lab
  - Small language (23 symbols, 11 are "convenience")
  - About 45 current implementations
  - Influenced Javascript, Ruby, Clojure
** Features of Racket
  - Functional programming (also not pure)
  - Tail-call optimization
  - Green and OS threads
  - Lexical Closures
  - Continuations
  - Powerful macro system
  - Pattern matching
  - Contracts
* http://i.imgur.com/mSIUhtX.jpg
  #+BEGIN_NOTES
  You may be feeling like this right now with all the jargon I just
  spewed at you, and that's OK.

  If all of those features that we just talked about don't make sense,
  that's fine. We'll be covering many of them, if not by name, as we
  present these languages.
  #+END_NOTES
* What is Functional Programming?
  #+BEGIN_NOTES
  OK, now is your first obligatory participation opportunity.
  Does anyone have a definition of functional programming?
  What concepts do you associate with functional programming?
  #+END_NOTES
** Did you guess
   #+ATTR_REVEAL: :frag (roll-in)
   - Lambdas λ
   - Higher-order functions
   - Functions are first-class citizens
** Well sure, but what we're after is
   #+ATTR_REVEAL: :frag (roll-in)
   - elimination of state
   - elimination of effects

   via

   #+ATTR_REVEAL: :frag appear
   - higher order functions
   - referential transparency
** In short
   - pass everything into scope
   - every scope returns a value
   - scope? yep, probably functions
   - don't mutate (esp. not out of scope)
* ML
  #+BEGIN_NOTES
  So, if everyone is ready, let's jump right in to our look at ML
  #+END_NOTES
** Values
   #+BEGIN_NOTES
   - "val" is our keyword for declaring values in ML
   - ML has type inference, so we don't have to specify the types of
     our declarations, but if we wish to, we can append a colon and
     then the type to make sure the type infer-er behaves the way we
     would like.
   #+END_NOTES
   #+BEGIN_SRC sml
   (* exactly the same *)
   val a = 5
   val b: int = 5

   a = b (* returns true - comparison, not assignment *)

   val a = 6 (* completely redeclare a - don't do this *)
   #+END_SRC
** Pairs
   #+BEGIN_NOTES
   - Tuples are heterogeneous typed and fixed-length
   - Tuples and they can be nested
   - We use hash functions to access parts of tuples
   - Accessing values with hash functions is 1-based, not 0-based
   - This is also our first look at calling functions. As you can see
     here, to call a function, we just put a space between a function
     and its arguments, though sometimes we need parenthesis to have
     the grouping work right, as they're right-associative.
   #+END_NOTES
   #+BEGIN_SRC sml
   val a: int * int = (5, 7)
   val b: int * (bool * int) = (3, (true, 2))

   #1 a = 5
   #2 a = 7
   #1 (#2 b) = true
   #+END_SRC
** Records
   #+BEGIN_NOTES
   - Records are another heterogeneously typed structure
   - Again, we access values through hash functions on the keys
   - Tuples are in fact just records with numeric keys
   #+END_NOTES
   #+BEGIN_SRC sml
   val x: {a:int, b:string, c:bool} = {a=1, b="2", c=false}
   val y = {foo=5}

   #a x + #foo y = 6

   val triple: string * bool * int = {2=false, 1="a", 3=5}
   #+END_SRC
** Lists
   #+BEGIN_NOTES
   - Lists are homogeneously typed and variable-length
   - The null function is our empty check for lists
   - hd and tl return the first and remaining elements of lists
   #+END_NOTES
   #+BEGIN_SRC sml
   val a: 'a list = []
   val b: int list = [1, 2, 3]

   val c = 0 :: b (* cons operator *)
   c = [0, 1, 2, 3]

   null [] = true
   null b = false

   hd b = 1
   tl b = [2, 3]
   tl (tl (tl b)) = []
   #+END_SRC
** Functions
   #+BEGIN_NOTES
   Here we see a couple functions defined.
   - Parameter types occur after parameters, separated by colon
   - ML is expression-based
   - Expressions are type safe
   - ∴ every if has a then and else, both returning same type
   - function return type follows parameters, separated by colon
   - function parameters are tuples
   #+END_NOTES
   #+BEGIN_SRC sml
   (* int -> int *)
   fun add1 (x: int) = x + 1

   (* int * int -> int *)
   fun pow (x: int, y: int) =
       if   y = 0
       then 1
       else x * pow(x, y - 1)

   fun cube (x: int): int = pow (x, 3)

   val b = (2, 3)
   pow b = 8
   pow b = pow(2,3)
   #+END_SRC
** Recursion
   #+BEGIN_NOTES
   - No "for" loops in SML
   - Recursion is standard for iteration
   - This function is not tail-call recursive, meaning it could
     blow the stack, but we'll talk more about that in a moment.
   #+END_NOTES
   #+BEGIN_SRC sml
   fun sum (xs: int list) =
       if   null xs
       then 0
       else hd xs + sum (tl xs)
   #+END_SRC
** ML Exercise 1
   #+BEGIN_NOTES
   fun concat (xs: int list, ys: int list) =
       if   null xs
       then ys
       else hd xs :: concat (tl xs, ys)
   #+END_NOTES
   Write a function that concatenate two lists of integers
** Local bindings
   #+BEGIN_NOTES
   - Lexical scoping gives us local bindings
   - local bindings unavailable outside function
   #+END_NOTES
   #+BEGIN_SRC sml
   fun local_bindings (x: int) =
       let val a = if x > 0 then x else ~x (* same as: abs x *)
           val b = a + 100
       in
           if b > 200 then b div 2 else b * b
       end

   fun range (x: int) =
       let
           fun range (y: int) =
               if y = x
               then x :: []
               else y :: range (y + 1)
       in
           range 0
       end
   #+END_SRC
** Options
   #+BEGIN_NOTES
   - Option is a container that holds a single value
   - We have isSome and valOf that work on options
   - isSome tells us if an Option is non-empty
   - valOf extracts values, or throws on NONE
   #+END_NOTES
   #+BEGIN_SRC sml
   val a: int option = SOME 5
   val b: int option = NONE

   isSome b = false
   val c: int = if isSome a then valOf a else 0
   #+END_SRC
** Options
   #+BEGIN_NOTES
   - Options provide a safer mechanism than exception handling
   - Functions can expect to handle failure without exceptions or null
   - The first example here would throw an Empty exception if the
     character can't be found
   - The second example won't throw, but uses a magic number as the
     return value in its failure condition
   #+END_NOTES
   #+BEGIN_SRC sml
    fun strchr (s: char list, c: char, acc: int) =
        if   hd s = c
        then acc
        else strchr (tl s, c, acc + 1)

    fun strchr' (s: char list, c: char, acc: int) =
        if   s = []
        then ~1
        else
            if   hd s = c
            then acc
            else strchr' (tl s, c, acc + 1)
   #+END_SRC
** Options
   #+BEGIN_NOTES
   - By using local bindings to create a private function, we get a
     type-safe wrapper around an otherwise unsafe or inconsistent function
   #+END_NOTES
   #+BEGIN_SRC sml
   fun strchr (s: string, c: char) =
   let
       fun strchr' (s: char list, acc: int) =
           if   s = []
           then ~1
           else
               if   hd s = c
               then acc
               else strchr' (tl s, acc + 1)

       val i = strchr' (explode s, 0)
   in
       if i = ~1 then NONE else SOME i
   end
   #+END_SRC
** ML Exercise 2
   #+BEGIN_NOTES
   fun hdOpt l =
     if   null l
     then NONE
     else SOME (hd l)
   #+END_NOTES
   Write a function hdOpt, which works like the hd function for lists,
   but returns an option wrapping the element. If the head of the list
   is not available, return NONE
** Data Types
   #+BEGIN_NOTES
   - Not only is there the Option type, ML lets us define our own custom types
   - The type is defined on the left
   - Various constructors for the type go on the right
   - Constructor can be "of" an existing type, or a singleton
   #+END_NOTES
   #+BEGIN_SRC sml
   datatype Toppings = Mustard of string
                       | Pickles of int
                       | PepperAndOnion of int * int
                       | Relish
   #+END_SRC
** Data Types
   #+BEGIN_NOTES
   - These types can then be used much like any other type
   - This includes in conjunction with container types like list and option
   #+END_NOTES
   #+BEGIN_SRC sml
   datatype HotDogStyle = ToppedWith of Toppings list
                          | Plain

   datatype HotDog = Link of HotDogStyle
                     | Brat of HotDogStyle;

   val myToppings:HotDogStyle = [Mustard("dijon"), Relish, Pickles(2)]
   val myDog = Brat (ToppedWith myToppings)
   val yourDog = SOME(Link Plain)
   #+END_SRC
** Type Bindings
   #+BEGIN_NOTES
   - In addition to data types, we have type bindings
   - Type bindings work as synonyms for existing types
   - Type bindings do not create new constructors
   - This is especially useful for records: records as params are typing hell
   #+END_NOTES
   #+BEGIN_SRC sml
   type hotdogOrder = int * HotDog

   val myOrder = 2 * myDog

   type attendee = { name       : string,
                     company    : string option,
                     experience : int }

   fun attendeeName (a: attendee):string = #name a

    attendeeName {name= "bob", company= NONE, experience= 2}
   #+END_SRC
** Pattern Matching
   #+BEGIN_NOTES
   - Case statements provide a way of "deconstructing" type constructors
   - Matches can be made on any type of constructor
   - this includes Option and list like we've seen already
   - Underscore is used as a wild card
   #+END_NOTES
   #+BEGIN_SRC sml
   fun likesBrats (d: HotDog) =
       case d of
           Brat _ => true
         | Link _ => false

   likesBrats (Brat Plain)
   #+END_SRC
** Pattern Matching
   #+BEGIN_NOTES
   - using local bindings can clean up nested cases
   - here 'style' is used to "break off" the top constructor to get
     the inner values
   - here's a sneak-peak at lambda syntax
   #+END_NOTES
   #+BEGIN_SRC sml
   fun likesRelish (d: HotDog) =
   let
       val style = case d of
                       Brat s => s
                     | Link s => s
   in
       case style of
           Plain => false
         | ToppedWith ts => List.exists (fn t => t = Relish) ts
   end

   likesRelish (Link Plain) = false
   likesRelish (Brat (ToppedWith [Relish])) = true
   #+END_SRC
** Pattern Matching
   #+BEGIN_NOTES
   - Again, matches can be made on any type of constructor
   - Case statements can be used to destructure basically any type
   #+END_NOTES
   #+BEGIN_SRC sml
   fun addTuple t =
       case t of
           (a, b, c) => a + b + c

   fun sum l =
       case l of
           []      => 0
         | h :: t  => h + (sum t)
   #+END_SRC
** Pattern Matching Function Signatures
   #+BEGIN_NOTES
   - Functions have a special form of case expression
   - They can be written as multiple definitions instead
   #+END_NOTES
   #+BEGIN_SRC sml
   fun likesBrats (Brat _) = true
     | likesBrats (Link _) = false

   fun sum []       = 0
     | sum (h :: t) = h + (sum t)
   #+END_SRC
** Recursive & Polymorphic types
   #+BEGIN_NOTES
   - Type variables are preceded with an apostrophe
   - They come before type name in data type definitions
   #+END_NOTES
   #+BEGIN_SRC sml
   datatype 'a Thing = Thing of 'a

   (case Thing 1 of Thing n => n) = 1
   (case Thing "Chimichanga" of Thing s => size s) = 11

   datatype 'a lyzt = Emptee | Cawns of 'a * 'a lyzt

   datatype ('a,'b) trie = Knowd of 'a * ('a,'b) trie * ('a,'b) trie
                         | Leef  of 'b
   #+END_SRC
** ML Exercise 3
   #+BEGIN_NOTES
   datatype ('a, 'b) either = Left of 'a | Right of 'b

   fun isLeft x = case x of Left a => true | Right b => false
   fun isRight x = not (isLeft x)
   #+END_NOTES
   Write a datatype "either" which is generic in two types. It should
   have two constructors, once for each type ­ Left and Right. Provide
   functions isLeft and isRight both of which take an either and
   return a boolean.
** Tail Recursion & Accumulator Pattern
   #+BEGIN_NOTES
   - Tail-call recursion optimization is of just called "tail recursion"
   - Return value of function is call to self
   - Can be optimized to not take up stack frames
   - No stack overflows ­ works like a loop
   - Accumulator pattern provides a private function which builds the result set
   #+END_NOTES
   #+BEGIN_SRC sml
   fun sum l =
       case l of
           []      => 0
         | h :: t  => h + (sum t)

   fun sum l =
     let fun f(is, acc) =
       case is of
           []      => acc
         | h :: t  => f(t, h + acc)
       in
         f(l, 0)
       end
   #+END_SRC
** ML Exercise 4
   #+BEGIN_NOTES
   fun concat (xs, ys) =
     let fun f ([],   l) = l
           | f (x::r, l) = f (r, x :: l)
     in
       f (f (xs, []), ys)
     end
   #+END_NOTES
   Write a function that concatenates two lists. It should be
   tail-call recursive and use pattern matching.
** Higher Order & First Class Functions
   #+BEGIN_NOTES
   - Higher order functions are functions that take other functions as
     arguments
   - Functions in ML are first-class because they can be stored and
     passed to functions as values, and returned from other functions
   - Functions can exist independently from definition as part of a
     module as lambdas with the "fn" keyword.
   #+END_NOTES
   #+BEGIN_SRC sml
   fun repeat (f, n, x) =       (* ('a -> 'a) * int * 'a -> 'a *)
       if n = 0 then x else f (repeat(f, n - 1, x))

   fun double x = x * 2         (* int -> int *)
   repeat (double, 5, 2) = 64

   repeat (fn x => x * x, 3, 2) = 256

   val square = fn x => x * x   (* int -> int *)
   repeat (square, 3, 2) = 256

   fun add y = fn x => x + y    (* int -> int -> int *)
   repeat (add 5, 10, 0) = 50
   #+END_SRC
** ML Exercise 5
   #+BEGIN_NOTES
   fun map (f, xs) =
     case xs of
       [] => []
     | x :: xs' => (f x) :: map(f, xs'))

   fun filter (f, xs) =
     case xs of
       [] => []
     | x :: xs => if f x then x :: filter(f, xs) else filter (f, xs)
   #+END_NOTES
   - Define the function map to operate on list such that:
   #+BEGIN_SRC sml
   map (fn x => x + 1, [1,2,3,4,5]) = [2,3,4,5,6]
   #+END_SRC
   - Define the function filter to operate on lists such that:
   #+BEGIN_SRC sml
   filter (fn x => x mod 2 = 0, [1,2,3,4,5,6]) = [2,4,6]
   #+END_SRC
** Folds
   #+BEGIN_NOTES
   - Fold is a function that repeatedly applies a function to a
     collection to accumulate a single result
   - folds are a common abstraction around the accumulator pattern we
     just discussed
   #+END_NOTES
   #+BEGIN_SRC sml
   fun fold (f, acc, xs) =
     case xs of
       []      => acc
     | x :: xs => fold (f, f(acc, x), xs)

     fold(fn (x, y) => x + y, 0, [1,2,3,4,5]) = 15
     fold(fn (x, y) => x * y, 1, [1,2,3,4,5]) = 120
   #+END_SRC
** ML Exercise 6
   #+BEGIN_NOTES
   fun foldLength xs = List.foldl(fn (x, y) => y + 1) 0 xs
   #+END_NOTES
   Compute the length of a list using a fold. For convenience, feel
   free to use List.foldl or List.foldr so you don't have to
   re-implement fold.
** Function composition
   #+BEGIN_NOTES
   - Function composition is creating a new function which executes
     two functions serially
   - The compose function is in the standard library as the function
     lowercase "o"
   #+END_NOTES
   #+BEGIN_SRC sml
   fun compose (f, g) = fn x => f(g x)

   fun add1 x = x + 1
   fun times2 x = x * 2

   (compose (times2, add1)) 2 = 6

   (times2 o add1) 2 = 6
   #+END_SRC
** The Pizza Operator
   #+BEGIN_NOTES
   - Also known as the forward pipe
   - Is an easier way to think about composition
   - Is an idiom in other, newer languages like F#
   - Often an easier way to think about composition because of the
     order of arguments
   #+END_NOTES
   #+BEGIN_SRC sml
   infix |>
   fun x |> f = f x

   2 |> add1 |> times2 = 6

   fun add1ThenTimes2 x = x |> add1 |> times2

   add1ThenTimes2 2 = 6
   #+END_SRC
** Currying & Partial Application
   #+BEGIN_NOTES
   - Currying abstracts the idea of functions that take multiple arguments
   - Currying changes functions that take multiple arguments and
     return a value into function that take 1 argument and return a
     function which expects the next argument
   - Partial application applies a single argument to a curried
     function and returns the next function
   - Some successors of ML do this automatically with every function
     for the purposes of magic. In SML however, you'll really only see
     it when it's absolutely necessary.
   - Ending on the concept of functions that return other functions
     may seem like an odd note to end on, but hopefully the reason
     this can be extremely valuable will be clear once we've talked
     about our next language, Scheme.
   #+END_NOTES
   #+BEGIN_SRC sml
   val add = fn x => fn y => x + y (* int -> int -> int *)
   add (1)(2) = 3
   add  1  2  = 3

   val add1 = add 1                (* int -> int *)
   add1 2 = 3
   #+END_SRC
* BREAK / Q & A
  #+BEGIN_NOTES
  #+END_NOTES
  #+BEGIN_SRC sml
  #+END_SRC
* Racket
  #+BEGIN_NOTES
  - Racket is a functional-focused language that has some additional
    features allowing imperative operations
  - So racket supports many things we've already seen: lambdas,
    closures, expression-based syntax and recursion instead of loops
  - Rather than a static type system, Racket is a dynamic language
    where data can be treated as many different types, and everything
    is data, even the code itself
  - As is famous of many LISPs, the syntax is very minimal, making use
    of mostly parenthesis with the occasional square bracket thrown in
    for good measure.
  - Because of its dynamic nature, Racket allows an additional family
    of features we couldn't have in a statically typed language like
    ML, such as macros, data-quoting and evaluation, and continuations
  #+END_NOTES
  - Functional w/ imperative features
  - Dynamically typed
  - Minimalist syntax
  - Macros & metaprogramming
** Defining things
   #+BEGIN_NOTES
   - In Racket, we use the define keyword similarly to how we would
     use the `val` expression in ML
   - Notice that pairs of parenthesis (known as "forms" in LISP) are
     evaluated with the first symbol for the operator or reference
     name, followed by any arguments (such as with + or = below)
   - Speaking of + and =, these are not special syntax, they are
     simply functions and can be treated exactly the same as any
     function we write ourselves
   #+END_NOTES
   #+BEGIN_SRC racket
   #lang racket
   (provide (all-defined-out))

   (define hello "Hello, world!")

   (define a 5)

   (define b (+ a 7))

   (= b 12) ; returns #t
   #+END_SRC
** Pairs
   #+BEGIN_NOTES
   - In Racket, "car" will give you the first element of a pair
   - In Racket, "cdr" will give you the second element of a pair
   - "car" and "cdr", which while terrible, are historic names based
     on the memory locations used in now-ancient IBM 704 machines,
     that LISP was originally implemented on so we're stuck with them.
   - Because deconstructing these memory locations was so important,
     there are a whole host of functions based on them for
     deconstructing nested sets of pairs, but you probably won't use
     them much, as making complex, nested data structures of pairs is
     rarely the best way to solve problems in Racket.
   #+END_NOTES
   #+BEGIN_SRC racket
   #lang racket
   (define p (cons 1 'a))

   p ; '(1 . a)

   (car p) ; 1
   ﻿(cdr p) ; 'a

 ﻿  (car (cdr (cons (cons 'a 'b) (cons 1 2)))) ; 1
   ﻿(cdr (car (cons (cons 'a 'b) (cons 1 2)))) ; 'b

   ﻿(caar (cons (cons 'a 'b) (cons 1 2))) ; 'a
   ﻿(cdar (cons (cons 'a 'b) (cons 1 2))) ; 'b
 ﻿  (cadr (cons (cons 'a 'b) (cons 1 2))) ; 1
   (cddr (cons (cons 'a 'b) (cons 1 2))) ; 2
   #+END_SRC
** Functions
   #+BEGIN_NOTES
   - Functions are defined using the same `define` keyword we use for
     defining symbols, but functions are defined as forms
   - Racket's `lambda` keyword is used similarly to ML's `fn` keyworkd
   - Racket's conditionals are a little different, as there are no
     `then` or `else` keywords. Rather, the `if` form simply takes
     either 2 or 3 arguments
   #+END_NOTES
   #+BEGIN_SRC racket
   (define (add1 x) (+ x 1))
   ; is syntactic sugar for
   (define add1 (lambda (x) (+ x 1)))

   (define (pow x y)
     (if (= y 0)
         1
         (* x (pow x (- y 1)))))
   #+END_SRC
** Lists
   #+BEGIN_NOTES
   - Lists in Racket are at the same time both similar to and different
     from ML's lists
   - Like ML, they are formed by "cons"ing values onto the front of
     existing lists
   - A list is composed of one element cons'd onto another list
   - In Racket, the empty list is represented by the null symbol, as
     opposed to ML's empty list brackets
   - For convenience, there is a list form which accepts an variable
     number of arguments to perform this successive "cons"ing for you
   - null? is the function which checks to see if a list is empty
   #+END_NOTES
   #+BEGIN_SRC racket
   (cons 1 (cons 2 (cons 3 (cons 4 null))))

   (define first-four (list 1 2 3 4))

   (= (car first-four) 1)          ; #t
   (= 3 (length (cdr first-four))) ; #t

   (define (sum xs)
     (if (null? xs)
         0
         (+ (car xs) (sum (cdr xs)))))
   #+END_SRC
** Scheme Exercise 1
   #+BEGIN_NOTES
   (define (concat xs ys)
     (if (null? xs)
         ys
         (cons (car xs) (concat (cdr xs) ys))))
   #+END_NOTES
   Write a function that concatenate two lists
** Dynamic typing
   #+BEGIN_NOTES
   With ML, after talking about Lists, we jumped into talking about
   defining our own special types. However in Racket, we're dealing
   with dynamic typing, so we can create our own very flexible data
   structures without the type checker getting in our way.
   - No compiler means we don't catch some small errors
   - Dynamic typing also means we can consume complex data structures
     without trying to appease the type system.
   - We can define a function which recursively sums a list of numbers
     or other lists without introducing any new concepts
   - Meanwhile the ML implementation requires defining a new datatype
     to wrap the int and int list datatypes and subsequently
     unwrapping those types with pattern matching to get at the
     results we're interested in.
   #+END_NOTES
   #+BEGIN_SRC racket
   (a + b)            ; you probably meant (+ a b)
   #+END_SRC
   #+BEGIN_SRC racket
   (define (flat-sum xs)
     (if (null? xs)
         0
         (if (number? (car xs))
             (+ (car xs) (flat-sum (cdr xs)))
             (+ (flat-sum (car xs)) (flat-sum (cdr xs))))))
   #+END_SRC
   #+BEGIN_SRC sml
   datatype IntOrList = Intlist of IntOrList list | Num of int

   fun flatSum []      = 0
     | flatSum (x::xs) =
         case x of
             Num n     => n + flatSum(xs)
           | Intlist n => flatSum(x) + flatSum(xs)

   flatSum [Num 1, Num 2, Num 3, Intlist [Num 4, Num 5, Num 6]];
   #+END_SRC
** Scheme Exercise 2
   #+BEGIN_NOTES
   (define (flatten-string xs)
     (if (null? xs)
         ""
         (if (string? (car xs))
             (string-append (car xs) (flatten-string (cdr xs)))
             (string-append (flatten-string (car xs)) (flatten-string (cdr xs))))))
   #+END_NOTES
   Write a function which concatenates a nested list of strings into
   a single string, such that
   #+BEGIN_SRC racket
   (eq?
    (flatten-string (list "a" "quick" (list "brown" "fox") "wrote" "racket"))
    "aquickbrownfoxwroteracket")
   #+END_SRC
   The Racket function for appending strings is string-append
** Structs
   #+BEGIN_NOTES
   Now, even though we can't define our own types in Racket like we
   can in ML, we can at least take a look at the way we define our own
   data structures
   - In Racket, the way we define our own structures of data are with
     structs
   - While they serve the same purpose as ML's records, just like
     everything in Racket, there's no type specificity
   #+END_NOTES
   #+BEGIN_SRC racket
   (struct triple (x y z) #:transparent)

   (define t (triple 1 2 3))

   (triple? t) ; #t
   (triple-x t) ; 1
   (triple-y t) ; 2
   (triple-z t) ; 3

   (triple 'a "b" (list "c" ''d 5))
   #+END_SRC
** Cond
   #+BEGIN_NOTES
   - In ML, pattern matching was our Swiss army knife of conditional
     branching and destructuring values based on their types
   - In Racket, the powerhouse for making these kinds of decisions is
     cond, which provides pairs of tests along with what to do if that
     test passes
   - In many ways, Racket's cond statement works much like switch
     statements in other languages
   - Traditionally, #t is the last case in a cond, similar to the
     "default" branch of switch statements
   #+END_NOTES
   #+BEGIN_SRC racket
   (define (flat-sum xs)
     (cond [(null? xs) 0]
           [(number? (car xs)) (+ (car xs) (flat-sum (cdr xs)))]
           [#t (+ (flat-sum (car xs)) (flat-sum (cdr xs)))]))
   #+END_SRC
** Scheme Exercise 3
   #+BEGIN_NOTES
   (define (flatten-string xs)
     (cond [(null? xs) ""]
           [(string? (car xs)) (string-append (car xs) (flatten-string (cdr xs)))]
           [#t (string-append (flatten-string (car xs)) (flatten-string (cdr xs)))]))
   #+END_NOTES
   Write a function that concatenates a nested list of strings into a
   single string using cond
** Local bindings
   #+BEGIN_NOTES
   - Like in ML, we can create local bindings that are only available
     inside the current scope
   - Unlike ML's `let`, Racket's `let` statement evaluates all
     statements in the environment in which the let is defined, so
     they cannot reference one another
   - However, Racket gives us several ways of using local bindings,
     like `let*` and `letrec`, which let us refer to other local
     bindings, as well as local define statements.
   - We'll see letrec shortly but its use is similar to the other let operations
   #+END_NOTES
   #+BEGIN_SRC racket
   (define (flat-sum xs)
     (cond [(null? xs) 0]
           [(number? (car xs))
               (let ([head     (car xs)]
                     [tail-sum (flat-sum (cdr xs))]
                     (+ head tail-sum))]
           [#t (let ([recur-sum (flat-sum (car xs))]
                     [tail-sum  (flat-sum (cdr xs))])
                     (+ recur-sum tail-sum))]))

   (define (add-five-then-double x)
      (let* ([added (+ x 5)]
             [doubled (* added 2)]
        doubled)))
   #+END_SRC
** Anonymous functions
   #+BEGIN_NOTES
   - Racket has a number of ways to deal with anonymous and local
     functions, but in the interest of brevity, we're going to focus
     on one expression, and that is lambda
   - Lambda works quite similarly to define as far as defining
     functions go
   - Just like in ML, lambda functions are first class citizens in
     Racket, and can be defined at top level, or in a let statement,
     passed as arguments, or returned as the result of a function call
   - It's important to note that if you're going to use a lambda in a
     let statement, you'll likely need the letrec form so that the
     lambda can reference itself
   #+END_NOTES
   #+BEGIN_SRC racket
   (define (square1 x) (* x x))

   (define square2 (lambda (x) (* x x)))

   ﻿(square1 5) ; 25
   ﻿(square2 5) ; 25

   (define (add y) (lambda (x) (+ x y)))
   ((add 5) 10) ; 15
   #+END_SRC
** Tail Recursion
   #+BEGIN_NOTES
   - Just like in ML, Racket can optimize tail-call recursive
     functions
   - Here we can see the use of the accumulator pattern with a local
     function definition lets us rewrite a recursive function so that
     it can be optimized
   - We can also finally see letrec in action
   #+END_NOTES
   #+BEGIN_SRC racket
   (define (sum1 xs)
     (cond [(null? xs) 0]
           [else (+ (car xs) (sum1 (cdr xs)))]))

   (define (sum2 xs)
     (letrec ([f (lambda (xs acc)
                 (cond [(null? xs) acc]
                       [else (f (cdr xs) (+ acc (car xs)))]))])
       (f xs 0)))
   #+END_SRC
** Scheme Exercise 4
   #+BEGIN_NOTES racket
   (define (concat xs ys)
     (letrec ([f (lambda (as bs)
                 (cond [(null? as) bs]
                       [else (f (cdr as) (cons (car as) bs))]))])
       (f (f xs null) ys)))
   #+END_NOTES
   Write a function that concatenates two lists. It should be
   tail-call recursive and use cond
** Scheme Exercise 5
   #+BEGIN_NOTES racket
   (define (my-map f lst)
    (cond
        [(null? lst) null]
        [else (cons (f (car lst)) (map f (cdr lst)))]))

   (define (my-filter f lst)
    (cond
        [(null? lst) null]
        [(f (car lst)) (cons (car lst) (filter f (cdr lst)))]
        [else (filter f (cdr lst))]))
   #+END_NOTES
   - Define the function map to operate on list such that:
   #+BEGIN_SRC racket
   (equal? (map (lambda (x) (+ x 1)) (list 1 2 3 4 5)) (list 2 3 4 5 6))
   #+END_SRC
   - Define the function filter to operate on lists such that:
   #+BEGIN_SRC racket
   (equal? (filter even? (list 1 2 3 4 5)) '(2 4))
   #+END_SRC
** Scheme exercise 6
   #+BEGIN_NOTES racket
    (define (foldLeft f acc xs)
      (cond
        [(null? xs) acc]
        [else (foldLeft f (f acc (car xs)) (cdr xs))]))
   #+END_NOTES
   Implement a left fold such that:
   #+BEGIN_SRC racket
   (foldLeft + 0 '(1 2 3 4 5))
   #+END_SRC
** Delayed execution with thunks
   #+BEGIN_NOTES
   - "Thunks" are a concept used for lazy evaluation in functional
     programming
   - Thunks are in essence 0-arity lambda expressions used to delay
     evaluation
   - This concept enables "lazy" and potentially infinite continuation
     of calculations to be delayed on an as-needed basis
   - Here, `b` is defined in terms of a thunk which just returns the
     a constant integer, but must be called as a function to retrieve
     its value, and is re-evaluated at each call.
   - The term "thunk" is allegedly a colloquialism for the past tense
     of "think", according to Eric Raymond, and references a
     compiler's ability to infer the return type of the function
   #+END_NOTES
   #+BEGIN_SRC racket
   ﻿(define a 5)
   (define b (lambda () 6))

   a ; 5
   ﻿b ; #<procedure:b>

   ﻿(+ a b)
   ; +: contract violation
   ;   expected: number?
   ;   given: #<procedure:b>

   ﻿(+ a (b)) ; 11
   #+END_SRC
** Streaming with thunks
   #+BEGIN_NOTES
   - A stream is a function which by convention returns a pair of a
     result cons'd onto a thunk which will make successive calls to
     the stream
   - By successively evaluating the `cdr` of the results of a call to
     a stream, we can get the following result
   - We could have implemented these in ML as well, but creating the
     necessary types would have been cumbersome.
   #+END_NOTES
   #+BEGIN_SRC racket
   (define forever-zeros (lambda () (cons 0 forever-zeros)))

   (car (forever-zeros)) ; 0
   (cdr (forever-zeros)) ; #<procedure:forever-zeros>

   ((cdr (forever-zeros))) ; '(0 . #<procedure:forever-zeros>)
   ((cdr ((cdr ((cdr ((cdr (forever-zeros))))))))) ; '(0 . #<procedure:forever-zeros>)
   #+END_SRC
** Streaming with thunks
   #+BEGIN_NOTES
   - Here we can define the stream of natural numbers from one to infinity
   - We'll use the `letrec` form of let, which allows the lambda
     produced by `next` to reference itself
   - Calling the `cdr` of natural numbers successively will then
     generate infinite results of adding one to the previous result
   #+END_NOTES
   #+BEGIN_SRC racket
   (define natural-numbers
     (letrec ([next (lambda (x) (cons x (lambda () (next (+ x 1)))))])
       (lambda () (next 1))))

   (car (natrual-numbers))                 ; 1
   (car ((cdr (natrual-numbers))))         ; 2
   (car ((cdr ((cdr (natural-numbers)))))) ; 3

   (define fibonacci
     (letrec ([fibs (lambda (a b) (cons a (lambda () (fibs b (+ a b)))))])
        (lambda () (fibs 1 1))))

   (car ((cdr ((cdr ((cdr ((cdr ((cdr (fibonacci))))))))))) ; 8

   (define (take n s)
     (if (eq? n 0)
         (cons (car s) null)
         (cons (car s) (take (- n 1) ((cdr s))))))

   (take 11 (fibonacci)) ; '(1 1 2 3 5 8 13 21 34 55 89 144)
   #+END_SRC
** Scheme Exercise 7
   #+BEGIN_NOTES racket
   (define (smap f s)
       (cons (f (car s))
             (lambda () (smap f ((cdr s))))))
   #+END_NOTES
   Define a function smap which performs a map over an infinite stream
   such that:
   #+BEGIN_SRC racket
   (eq? (take 5 (smap (lambda (x) (+ x 1)) (fibonacci))) 9)
   (eq? (take 5 (smap (lambda (x) (* x 2)) (fibonacci))) 16)
   #+END_SRC
** Macros
   #+BEGIN_NOTES
   - Macros are an extremely powerful tool which let us treat the
     structures of Racket itself as data structures
   - By letting us alter the syntax of the language itself and
     treating expressions as data rather than executing them directly,
     we can change the semantics of how we use Racket
   - If we got tired of having to wrap our thunks in lambdas to
     prevent their execution, we could create a macro "thunk" that
     does it for us
   - It's important to note that because we're dealing with macro
     expansion as opposed to actually calling code, we can pass around
     forms like (fibs 1 1) without them being evaluated, or even
     if they haven't been defined at all
   #+END_NOTES
   #+BEGIN_SRC racket
   (define-syntax thunk
     (syntax-rules ()
       [(thunk e) (lambda () e)]))

   (define fibonacci
     (letrec ([fibs (lambda (a b) (cons a (thunk (fibs b (+ a b)))))])
       (thunk (fibs 1 1))))

   (car (fibonacci)) ; 1
   (car ((cdr ((cdr ((cdr ((cdr (fibonacci)))))))))) ; 5
   #+END_SRC
** Macros
   #+BEGIN_NOTES
   - We can even use macros to abstract out all of the effort and
     generalize building streams in this way, exploiting the fact that
     macros won't actually evaluate their terms until called as code.
   #+END_NOTES
   #+BEGIN_SRC racket
   ﻿(define-syntax thunk-iter-2
     (syntax-rules ()
       [(thunk-iter-2 f operation start-exp)
        (letrec ([f (lambda (a b) (cons a (thunk (f b (operation a b)))))])
          (thunk start-exp))]))

﻿   (define fibonacci2 (thunk-iter-2 fibs + (fibs 1 1)))

   (car ((cdr ((cdr ((cdr ((cdr (fibonacci2)))))))))) ; 5

   (define pows (thunk-iter-2 f * (f 1 2)))
   (car ((cdr ((cdr ((cdr ((cdr (pows)))))))))) ; 8
   (car ((cdr ((cdr ((cdr ((cdr ((cdr (pows)))))))))))) ; 32
   #+END_SRC
* Let's compare
  #+BEGIN_NOTES
  - ML and Racket are alike in many ways
  - They're functional: higher-order functions, discourage mutation,
    lexically scoped for encapsulating data
  - Type systems are very different
  - ML's type system is defensive at compile time, forces programmer
    to tell ML what kind of data are allowed up front, rejects many
    programs at compile time
  - Racket's type system is extremely flexible, allowing the
    programmer to decide how to handle code or data as they see fit
  #+END_NOTES
  - Both functional-first languages
  - Very different type systems
** Static Checking
  #+BEGIN_NOTES
  - ML's type system can help us by catching if we try and pass a list
    to a function that takes an integer
  - Static type checking also helps us from having to do type checking
    in our program, and prevents us from accessing undefined data
  - ML's type checking prevents us from using operations on the
    wrong types: if we didn't define it, it won't compile
  - ML's typing also prevents us from redundantly checking types,
    something a language like javascript might do at the beginning of
    every function call
  - As safe as ML is, we can still make mistakes like taking the head
    of the empty list, or flipping the branches of a conditional
  - With ML's safety comes complexity. We might get bizarre error
    messages and be forced to handle a condition even though we know
    based on our code that the error ML is helping us to prevent can
    never actually occur.
  #+END_NOTES
** Dynamic Typing
  #+BEGIN_NOTES
  - Racket's type system lets us write functions that might take an
    integer or a list and return either an integer or a list: to
    Racket it's just un-typed data.
  - Additionally, we've seen that we can actually change Racket's type
    system dynamically as we write our program using macros, which
    would break all of the safety provided in ML
  #+END_NOTES
* BREAK / Q & A
  #+BEGIN_NOTES
  #+END_NOTES
  #+BEGIN_SRC racket
  #+END_SRC
* Practice Time
  #+BEGIN_NOTES
  - Now we will have the rest of the period to work on exercises
  - I will present a problem on the screen, and you should use your
    own laptop to implement the exercise in the programming language
    you normally work in.
  - I would like you not to use some fancy new language that you're
    trying to learn, but rather whatever language you work with daily
    or know best.
  - Try to use the best functional style possible
  - No mutable state
  - Referential Transparency
  - Always return a new object
  - Try to use recursion instead of loops
  - Use higher-order functions when appropriate
  - After some time or if it looks like many folks are done, I will
    present a solution, and ask that you post your answers in a gist
    or in the Slack channel so that we can all learn from them.
  - Don't worry if your answers seem bad, you're probably not using a
    functional programming language!
  - If you don't have your own computer or you'd like to pair up with
    other people using your language, let's organize now!
  #+END_NOTES
  - Use the language that you know best
  - Try to use the best functional style possible
  - No mutable state
  - Referential Transparency
  - Always return a new object
  - Try to use recursion instead of loops
  - Use higher-order functions when appropriate
** Practice Problem 1
   #+BEGIN_NOTES js
   function last(xs) {
     if (isEmpty(tail(xs))) {
       return head(xs);
     } else {
       return last(tail(xs));
     }
   }
   #+END_NOTES
   Write a function that returns the last element of a list.
** Practice Problem 2
   #+BEGIN_NOTES js
   function nth(n, xs) {
     if (n === 0) {
       return head(xs);
     } else {
       return nth(n - 1, tail(xs));
     }
   }
   #+END_NOTES
   Write a function to find the n-th element of a list.
** Practice Problem 3
   #+BEGIN_NOTES js
   function reverse(xs) {
     let f = (xs, acc) => {
       if (isEmpty(xs)) {
         return acc;
       } else {
         return f(tail(xs), cons(head(xs), acc));
       }
     };
    return f(xs, []);
   }
   #+END_NOTES
   Write a function to reverse a list.
** Practice Problem 4
   #+BEGIN_NOTES js
   function flatten(xs) {
     if(isEmpty(xs)) {
       return [];
     } else if (Array.isArray(head(xs))) {
       return flatten(head(xs)).concat(flatten(tail(xs)));
     } else {
       return cons(head(xs), flatten(tail(xs)));
     }
   }
   #+END_NOTES
   Write a function to flatten nested list structures.
** Practice Problem 5
   #+BEGIN_NOTES js
   function gcd(x, y) {
     if (y === 0) {
       return x;
     } else {
       return gcd(y, x % y);
     }
   }
   #+END_NOTES
   Write a function to determine the greatest common denominator of
   two integers. Look up Euclid's algorithm if you need are unsure
   what this means.
** Practice Problem 6
   #+BEGIN_NOTES js
   class Node {
     constructor(value, left, right) {
       this.value = value;
       this.left = left;
       this.right = right;
     }

     add(value) {
       if (value < this.value) {
         if (this.left)
           return new Node(this.value, this.left.add(value), this.right);
         else
           return new Node(this.value, new Node(value), this.right);
       } else {
         if (this.right)
           return new Node(this.value, this.left, this.right.add(value));
         else
           return new Node(this.value, this.left, new Node(value));
       }
     }
   #+END_NOTES
   Implement an immutable binary tree. It should have an 'add'
   function which returns a copy of itself, with the new elements in
   the appropriate part of the tree.
** Practice Problem 7
   #+BEGIN_NOTES js
   function bmap(f, tree) {
     if (!tree)
       return undefined;
     else
       return new Node(f(tree.value), bmap(f, tree.left), bmap(f, tree.right));
   }
   #+END_NOTES
   Implement the higher-order function map to work on your binary tree structure.
** Practice Problem 8
   #+BEGIN_NOTES js
   function zeros() {
     return () => cons(0, zeros());
   }

   function take(n, s) {
     if (n === 0) {
       return [];
     } else {
       let x = s();
       return cons(head(x), take(n - 1, head(tail(x))));
     }
   }
   #+END_NOTES
   Implement an infinite stream of the number 0. Implement a take
   function to take n elements from the stream and put them in a list.
** Practice Problem 9
   #+BEGIN_NOTES js
   function fibonacci() {
     function f(a, b) {
       return cons(a, () => f(b, a + b));
     }
     return () => f(1, 1);
   }
   #+END_NOTES
   Implement an infinite stream of the fibonacci sequence.
** Practice Problem 10
   #+BEGIN_NOTES js
   #+END_NOTES
   Implement a function to filter an infinite stream of values.
* Final Q/A
  Thank you to everyone for participating, and special thanks to my
  employer, Detroit Labs for putting up with my love of archaic and
  esoteric programming languages. Come see our booth right next to
  registration!
